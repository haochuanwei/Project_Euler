def Euler_Problem_1(n=1000):
    '''
    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
    Find the sum of all the multiples of 3 or 5 below 1000.
    '''
    # compute the number of such multiples in three sets
    num_multiples_of_3   = (n-1) // 3
    num_multiples_of_5   = (n-1) // 5
    num_shared_multiples = (n-1) // (3 * 5)

    # compute the sum of each set
    def sum_one_up_to_k(k):
        return (k ** 2 + k) / 2
    sum_multiples_of_3   = sum_one_up_to_k(num_multiples_of_3) * 3
    sum_multiples_of_5   = sum_one_up_to_k(num_multiples_of_5) * 5
    sum_shared_multiples = sum_one_up_to_k(num_shared_multiples) * (3 * 5)

    # use inclusion/exclusion to compute the final answer
    retval = sum_multiples_of_3 + sum_multiples_of_5 - sum_shared_multiples
    return retval

def Euler_Problem_2(n=4000000):
    '''
    Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    '''
    # note that for every triple starting with (1, 2, 3), the middle value is even
    def new_triple(old_triple):
        _left, _mid, _right = old_triple
        left = _mid + _right
        mid = left + _right
        right = left + mid
        return (left, mid, right)

    retval = 0
    current_triple = (1, 2, 3)
    while True:
        if current_triple[1] > n:
            break
        retval += current_triple[1]
        current_triple = new_triple(current_triple)
    return retval

def Euler_Problem_3(n=600851475143):
    '''
    The prime factors of 13195 are 5, 7, 13 and 29.
    What is the largest prime factor of the number 600851475143 ?
    '''
    # start from 2 and keep dividing
    def least_divisor(num, floor=2):
        '''
        Find the least divisor of a number, above some floor.
        '''
        assert num >= floor
        trial = floor
        while num % trial != 0:
            trial += 1
        return trial

    greatest_divisor = 2
    value            = n
    while greatest_divisor < value:
        greatest_divisor = least_divisor(value, greatest_divisor)
        value           /= greatest_divisor

    return greatest_divisor

def Euler_Problem_4(n=3):
    '''
    A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 * 99.
    Find the largest palindrome made from the product of two 3-digit numbers.
    '''
    def is_a_palindrome(num):
        assert isinstance(num, int)
        str_form = str(num)
        n_digits = len(str_form)
        for k in range(0, (n_digits+1)//2):
            if str_form[k] != str_form[-1-k]:
                return False
        return True

    assert n >= 2
    greatest_product = 0
    # brute-force approach that searches the high end of possible products
    upper_bound = 10 ** n - 1
    lower_bound = int(0.9 * upper_bound)
    for p in range(upper_bound, lower_bound, -1):
        for q in range(upper_bound, lower_bound, -1):
            candidate = p * q
            if candidate > greatest_product:
                if is_a_palindrome(candidate):
                    greatest_product = candidate
    return greatest_product

def Euler_Problem_5(n=20):
    '''
    2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    '''
    def lowest_divisor(num):
        assert num >= 2
        trial = 2
        while num % trial != 0:
            trial += 1
        return trial

    def subproblem(num, cache):
        '''
        Uses a cache to store intermediate results.
        '''
        assert isinstance(num, int)
        assert num > 0 
        # base case
        if num == 1:
            cache[num] = 1
            return cache[num] 

        # recursion / dynamic programming
        if not num-1 in cache.keys():
            prev = subproblem(num-1, cache)
        if prev % num == 0:
            cache[num] = prev
        else:
            factor = lowest_divisor(num)
            cache[num] = prev * factor
        return cache[num]

    solution_cache = {}
    return subproblem(n, solution_cache)
