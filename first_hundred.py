def Euler_Problem_1(n=1000):
    '''
    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
    Find the sum of all the multiples of 3 or 5 below 1000.
    '''
    # compute the number of such multiples in three sets
    num_multiples_of_3   = (n-1) // 3
    num_multiples_of_5   = (n-1) // 5
    num_shared_multiples = (n-1) // (3 * 5)

    # compute the sum of each set
    def sum_one_up_to_k(k):
        return (k ** 2 + k) / 2
    sum_multiples_of_3   = sum_one_up_to_k(num_multiples_of_3) * 3
    sum_multiples_of_5   = sum_one_up_to_k(num_multiples_of_5) * 5
    sum_shared_multiples = sum_one_up_to_k(num_shared_multiples) * (3 * 5)

    # use inclusion/exclusion to compute the final answer
    retval = sum_multiples_of_3 + sum_multiples_of_5 - sum_shared_multiples
    return retval

def Euler_Problem_2(n=4000000):
    '''
    Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    '''
    # note that for every triple starting with (1, 2, 3), the middle value is even
    def new_triple(old_triple):
        _left, _mid, _right = old_triple
        left = _mid + _right
        mid = left + _right
        right = left + mid
        return (left, mid, right)

    retval = 0
    current_triple = (1, 2, 3)
    while True:
        if current_triple[1] > n:
            break
        retval += current_triple[1]
        current_triple = new_triple(current_triple)
    return retval

def Euler_Problem_3(n=600851475143):
    '''
    The prime factors of 13195 are 5, 7, 13 and 29.
    What is the largest prime factor of the number 600851475143 ?
    '''
    # start from 2 and keep dividing
    def least_divisor(num, floor=2):
        '''
        Find the least divisor of a number, above some floor.
        '''
        assert num >= floor
        trial = floor
        while num % trial != 0:
            trial += 1
        return trial

    greatest_divisor = 2
    value            = n
    while greatest_divisor < value:
        greatest_divisor = least_divisor(value, greatest_divisor)
        value           /= greatest_divisor

    return greatest_divisor

def Euler_Problem_4(n=3):
    '''
    A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 * 99.
    Find the largest palindrome made from the product of two 3-digit numbers.
    '''
    def is_a_palindrome(num):
        assert isinstance(num, int)
        str_form = str(num)
        n_digits = len(str_form)
        for k in range(0, (n_digits+1)//2):
            if str_form[k] != str_form[-1-k]:
                return False
        return True

    assert n >= 2
    greatest_product = 0
    # brute-force approach that searches the high end of possible products
    upper_bound = 10 ** n - 1
    lower_bound = int(0.9 * upper_bound)
    for p in range(upper_bound, lower_bound, -1):
        for q in range(upper_bound, lower_bound, -1):
            candidate = p * q
            if candidate > greatest_product:
                if is_a_palindrome(candidate):
                    greatest_product = candidate
    return greatest_product

def Euler_Problem_5(n=20):
    '''
    2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    '''
    def lowest_divisor(num):
        assert num >= 2
        trial = 2
        while num % trial != 0:
            trial += 1
        return trial

    def subproblem(num, cache):
        '''
        Uses a cache to store intermediate results.
        '''
        assert isinstance(num, int)
        assert num > 0 
        # base case
        if num == 1:
            cache[num] = 1
            return cache[num] 

        # recursion / dynamic programming
        if not num-1 in cache.keys():
            prev = subproblem(num-1, cache)
        if prev % num == 0:
            cache[num] = prev
        else:
            factor = lowest_divisor(num)
            cache[num] = prev * factor
        return cache[num]

    solution_cache = {}
    return subproblem(n, solution_cache)

def Euler_Problem_6(n=100):
    '''
    The sum of the squares of the first ten natural numbers is,
    1^2 + 2^2 + ... + 10^2 = 385
    The square of the sum of the first ten natural numbers is,
    (1 + 2 + ... + 10)^2 = 55^2 = 3025
    Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.
    Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
    '''
    # looks like brute force gives you O(n) or O(n logn), which is not bad...
    # but we can do better with mathematical insight.
    def sum_of_integer_squares(k):
        '''
        Use the formula 1^2 + 2^2 + ... + n^2 = (n * (n+1) * (2n+1)) / 6.
        '''
        return (k * (k+1) * (2*k + 1)) / 6
   
    def square_of_integer_sums(k):
        '''
        Use the formula 1 + 2 + ... + n = n (n+1) / 2.
        '''
        return (n * (n+1) / 2) ** 2

    # O(logn) basic operations
    sqsum = square_of_integer_sums(n)
    sumsq = sum_of_integer_squares(n)
    return int(sqsum - sumsq)

def Euler_Problem_7(n=10001):
    '''
    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
    What is the 10001st prime number?
    '''
    def has_nontrivial_divisor(num):
        assert num >= 2
        trial = 2
        while num % trial != 0:
            trial += 1
        if trial < num:
            return True
        else:
            return False
    
    # brute force: check numbers one by one
    value = 1
    num_primes = 0
    while num_primes < n:
        value += 1
        if not has_nontrivial_divisor(value):
            num_primes += 1
    return value

def Euler_Problem_8(n=13):
    '''
    The four adjacent digits in the 1000-digit number that have the greatest product are 9 * 9 * 8 * 9 = 5832.
    73167176531330624919225119674426574742355349194934
    96983520312774506326239578318016984801869478851843
    85861560789112949495459501737958331952853208805511
    12540698747158523863050715693290963295227443043557
    66896648950445244523161731856403098711121722383113
    62229893423380308135336276614282806444486645238749
    30358907296290491560440772390713810515859307960866
    70172427121883998797908792274921901699720888093776
    65727333001053367881220235421809751254540594752243
    52584907711670556013604839586446706324415722155397
    53697817977846174064955149290862569321978468622482
    83972241375657056057490261407972968652414535100474
    82166370484403199890008895243450658541227588666881
    16427171479924442928230863465674813919123162824586
    17866458359124566529476545682848912883142607690042
    24219022671055626321111109370544217506941658960408
    07198403850962455444362981230987879927244284909188
    84580156166097919133875499200524063689912560717606
    05886116467109405077541002256983155200055935729725
    71636269561882670428252483600823257530420752963450
    Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
    '''
    from functools import reduce
    # preprocessing
    series = '''\
    73167176531330624919225119674426574742355349194934\
    96983520312774506326239578318016984801869478851843\
    85861560789112949495459501737958331952853208805511\
    12540698747158523863050715693290963295227443043557\
    66896648950445244523161731856403098711121722383113\
    62229893423380308135336276614282806444486645238749\
    30358907296290491560440772390713810515859307960866\
    70172427121883998797908792274921901699720888093776\
    65727333001053367881220235421809751254540594752243\
    52584907711670556013604839586446706324415722155397\
    53697817977846174064955149290862569321978468622482\
    83972241375657056057490261407972968652414535100474\
    82166370484403199890008895243450658541227588666881\
    16427171479924442928230863465674813919123162824586\
    17866458359124566529476545682848912883142607690042\
    24219022671055626321111109370544217506941658960408\
    07198403850962455444362981230987879927244284909188\
    84580156166097919133875499200524063689912560717606\
    05886116467109405077541002256983155200055935729725\
    71636269561882670428252483600823257530420752963450\
    '''.replace(' ', '')
    series = list(map(int, list(series)))
    assert len(series) > n

    # linear scan of all products
    tmp_prod = reduce(lambda a, b: a * b, series[0:n])
    max_prod = tmp_prod
    # attempt to cheat the product at O(1)
    for k in range(1, len(series)-n):
        # attempt works if the term to be removed is nonzero
        if series[k-1] > 0:
            tmp_prod = tmp_prod * series[k+n-1] / series[k-1]
        # attmpt fails is the term to be removed is zero
        else:
            tmp_prod = reduce(lambda a, b: a * b, series[k:(k+n)])
        # update product
        if tmp_prod > max_prod:
            max_prod = tmp_prod
    return max_prod

def Euler_Problem_9(n=1000):
    '''
    A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
    a^2 + b^2 = c^2
    For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
    There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    Find the product abc.
    '''
    import math
    assert n > 10
    # first assume that a <= b < c < n/2. Then, for c to be an integer we can't have a=b.
    # hence assume that a < b < c and that n/3 < 3.

    # brute-force O(n^2) approach
    for c in range(n//2, n//3, -1):
        c_sq = c ** 2
        for b in range(c-1, int(c / math.sqrt(2)), -1):
            a = n - c - b
            if a ** 2 + b ** 2 == c_sq:
                return a * b * c
    return -1

def Euler_Problem_10(n=2000000):
    '''
    The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
    Find the sum of all the primes below two million.
    '''
    def divisible_by_prime(num, primes):
        assert num >= 2
        for _p in primes:
            if num % _p == 0:
                return True
        return False
    
    # brute force: check numbers one by one, starting at 3
    # also maintain a list of primes to divide by
    value = 2
    current_primes = [2]
    while value < n-1:
        if value % 10000 == 0:
            print(value)
        value += 1
        if not divisible_by_prime(value, current_primes):
            current_primes.append(value)
    return sum(current_primes)

def Euler_Problem_11(k=4):
    '''
    In the 20 * 20 grid below, four numbers along a diagonal line have been marked in red.
    08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
    49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
    81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
    52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
    22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
    24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
    32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
    67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
    24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
    21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
    78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
    16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
    86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
    19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
    04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
    88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
    04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
    20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
    20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
    01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
    The product of these numbers is 26 * 63 * 78 * 14 = 1788696.
    What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20 * 20 grid?
    '''
    # This problem always takes at least O(M^2) where M is the size of the grid.
    # Here's the argument:
    # Consider the reduced problem where we only care about adjacent numbers in the horizontal direction. Then we need a linear scan in each row, giving a running time of O(M^2).
    # Note the brute force takes O(M^2), which is good enough in asymtotic scaling.

    # construct the array
    import numpy as np
    arr_in_str_form = '''
    08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
    49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
    81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
    52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
    22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
    24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
    32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
    67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
    24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
    21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
    78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
    16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
    86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
    19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
    04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
    88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
    04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
    20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
    20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
    01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
    '''
    arr_in_str_form = [_x for _x in arr_in_str_form.split('\n') if len(_x) > 0]
    arr = [[int(_z) for _z in _y.split(' ') if len(_z) > 0] for _y in arr_in_str_form]
    arr = np.array([_a for _a in arr if len(_a) > 0])
    assert arr.shape == (20, 20)
    
    # set up max product variable
    max_prod = 0

    # consider horizontal and vertical
    for i in range(0, 20):
        for j in range(0, 20-k+1):
            # horizontal
            value = 1
            for shift in range(0, k):
                value *= arr[i][j+shift]
            if value > max_prod:
                max_prod = value

            # vertical
            value = 1
            for shift in range(0, k):
                value *= arr[j+shift][i]
            if value > max_prod:
                max_prod = value

    # consider diagonal directions 
    for i in range(0, 20-k+1):
        for j in range(0, 20-k+1):
            # upper-left-to-lower-right
            value = 1
            for shift in range(0, k):
                value *= arr[i+shift][j+shift]
            if value > max_prod:
                max_prod = value

            # upper-right-to-lower-left
            value = 1
            for shift in range(0, k):
                value *= arr[i+shift][20-1-j-shift]
            if value > max_prod:
                max_prod = value

    return max_prod
