def Euler_Problem_1(n=1000):
    '''
    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
    Find the sum of all the multiples of 3 or 5 below 1000.
    '''
    # compute the number of such multiples in three sets
    num_multiples_of_3   = (n-1) // 3
    num_multiples_of_5   = (n-1) // 5
    num_shared_multiples = (n-1) // (3 * 5)

    # compute the sum of each set
    def sum_one_up_to_k(k):
        return (k ** 2 + k) / 2
    sum_multiples_of_3   = sum_one_up_to_k(num_multiples_of_3) * 3
    sum_multiples_of_5   = sum_one_up_to_k(num_multiples_of_5) * 5
    sum_shared_multiples = sum_one_up_to_k(num_shared_multiples) * (3 * 5)

    # use inclusion/exclusion to compute the final answer
    retval = sum_multiples_of_3 + sum_multiples_of_5 - sum_shared_multiples
    return retval

def Euler_Problem_2(n=4000000):
    '''
    Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    '''
    # note that for every triple starting with (1, 2, 3), the middle value is even
    def new_triple(old_triple):
        _left, _mid, _right = old_triple
        left = _mid + _right
        mid = left + _right
        right = left + mid
        return (left, mid, right)

    retval = 0
    current_triple = (1, 2, 3)
    while True:
        if current_triple[1] > n:
            break
        retval += current_triple[1]
        current_triple = new_triple(current_triple)
    return retval

def Euler_Problem_3(n=600851475143):
    '''
    The prime factors of 13195 are 5, 7, 13 and 29.
    What is the largest prime factor of the number 600851475143 ?
    '''
    # start from 2 and keep dividing
    def least_divisor(num, floor=2):
        '''
        Find the least divisor of a number, above some floor.
        '''
        assert num >= floor
        trial = floor
        while num % trial != 0:
            trial += 1
        return trial

    greatest_divisor = 2
    value            = n
    while greatest_divisor < value:
        greatest_divisor = least_divisor(value, greatest_divisor)
        value           /= greatest_divisor

    return greatest_divisor

def Euler_Problem_4(n=3):
    '''
    A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 * 99.
    Find the largest palindrome made from the product of two 3-digit numbers.
    '''
    def is_a_palindrome(num):
        assert isinstance(num, int)
        str_form = str(num)
        n_digits = len(str_form)
        for k in range(0, (n_digits+1)//2):
            if str_form[k] != str_form[-1-k]:
                return False
        return True

    assert n >= 2
    greatest_product = 0
    # brute-force approach that searches the high end of possible products
    upper_bound = 10 ** n - 1
    lower_bound = int(0.9 * upper_bound)
    for p in range(upper_bound, lower_bound, -1):
        for q in range(upper_bound, lower_bound, -1):
            candidate = p * q
            if candidate > greatest_product:
                if is_a_palindrome(candidate):
                    greatest_product = candidate
    return greatest_product

def Euler_Problem_5(n=20):
    '''
    2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    '''
    def lowest_divisor(num):
        assert num >= 2
        trial = 2
        while num % trial != 0:
            trial += 1
        return trial

    def subproblem(num, cache):
        '''
        Uses a cache to store intermediate results.
        '''
        assert isinstance(num, int)
        assert num > 0 
        # base case
        if num == 1:
            cache[num] = 1
            return cache[num] 

        # recursion / dynamic programming
        if not num-1 in cache.keys():
            prev = subproblem(num-1, cache)
        if prev % num == 0:
            cache[num] = prev
        else:
            factor = lowest_divisor(num)
            cache[num] = prev * factor
        return cache[num]

    solution_cache = {}
    return subproblem(n, solution_cache)

def Euler_Problem_6(n=100):
    '''
    The sum of the squares of the first ten natural numbers is,
    1^2 + 2^2 + ... + 10^2 = 385
    The square of the sum of the first ten natural numbers is,
    (1 + 2 + ... + 10)^2 = 55^2 = 3025
    Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.
    Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
    '''
    # looks like brute force gives you O(n) or O(n logn), which is not bad...
    # but we can do better with mathematical insight.
    def sum_of_integer_squares(k):
        '''
        Use the formula 1^2 + 2^2 + ... + n^2 = (n * (n+1) * (2n+1)) / 6.
        '''
        return (k * (k+1) * (2*k + 1)) / 6
   
    def square_of_integer_sums(k):
        '''
        Use the formula 1 + 2 + ... + n = n (n+1) / 2.
        '''
        return (n * (n+1) / 2) ** 2

    # O(logn) basic operations
    sqsum = square_of_integer_sums(n)
    sumsq = sum_of_integer_squares(n)
    return int(sqsum - sumsq)

def Euler_Problem_7(n=10001):
    '''
    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
    What is the 10001st prime number?
    '''
    def has_nontrivial_divisor(num):
        assert num >= 2
        trial = 2
        while num % trial != 0:
            trial += 1
        if trial < num:
            return True
        else:
            return False
    
    # brute force: check numbers one by one
    value = 1
    num_primes = 0
    while num_primes < n:
        value += 1
        if not has_nontrivial_divisor(value):
            num_primes += 1
    return value

def Euler_Problem_8(n=13):
    '''
    The four adjacent digits in the 1000-digit number that have the greatest product are 9 * 9 * 8 * 9 = 5832.
    73167176531330624919225119674426574742355349194934
    96983520312774506326239578318016984801869478851843
    85861560789112949495459501737958331952853208805511
    12540698747158523863050715693290963295227443043557
    66896648950445244523161731856403098711121722383113
    62229893423380308135336276614282806444486645238749
    30358907296290491560440772390713810515859307960866
    70172427121883998797908792274921901699720888093776
    65727333001053367881220235421809751254540594752243
    52584907711670556013604839586446706324415722155397
    53697817977846174064955149290862569321978468622482
    83972241375657056057490261407972968652414535100474
    82166370484403199890008895243450658541227588666881
    16427171479924442928230863465674813919123162824586
    17866458359124566529476545682848912883142607690042
    24219022671055626321111109370544217506941658960408
    07198403850962455444362981230987879927244284909188
    84580156166097919133875499200524063689912560717606
    05886116467109405077541002256983155200055935729725
    71636269561882670428252483600823257530420752963450
    Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
    '''
    from functools import reduce
    # preprocessing
    series = '''\
    73167176531330624919225119674426574742355349194934\
    96983520312774506326239578318016984801869478851843\
    85861560789112949495459501737958331952853208805511\
    12540698747158523863050715693290963295227443043557\
    66896648950445244523161731856403098711121722383113\
    62229893423380308135336276614282806444486645238749\
    30358907296290491560440772390713810515859307960866\
    70172427121883998797908792274921901699720888093776\
    65727333001053367881220235421809751254540594752243\
    52584907711670556013604839586446706324415722155397\
    53697817977846174064955149290862569321978468622482\
    83972241375657056057490261407972968652414535100474\
    82166370484403199890008895243450658541227588666881\
    16427171479924442928230863465674813919123162824586\
    17866458359124566529476545682848912883142607690042\
    24219022671055626321111109370544217506941658960408\
    07198403850962455444362981230987879927244284909188\
    84580156166097919133875499200524063689912560717606\
    05886116467109405077541002256983155200055935729725\
    71636269561882670428252483600823257530420752963450\
    '''.replace(' ', '')
    series = list(map(int, list(series)))
    assert len(series) > n

    # linear scan of all products
    tmp_prod = reduce(lambda a, b: a * b, series[0:n])
    max_prod = tmp_prod
    # attempt to cheat the product at O(1)
    for k in range(1, len(series)-n):
        # attempt works if the term to be removed is nonzero
        if series[k-1] > 0:
            tmp_prod = tmp_prod * series[k+n-1] / series[k-1]
        # attmpt fails is the term to be removed is zero
        else:
            tmp_prod = reduce(lambda a, b: a * b, series[k:(k+n)])
        # update product
        if tmp_prod > max_prod:
            max_prod = tmp_prod
    return max_prod

def Euler_Problem_9(n=1000):
    '''
    A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
    a^2 + b^2 = c^2
    For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
    There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    Find the product abc.
    '''
    import math
    assert n > 10
    # first assume that a <= b < c < n/2. Then, for c to be an integer we can't have a=b.
    # hence assume that a < b < c and that n/3 < 3.

    # brute-force O(n^2) approach
    for c in range(n//2, n//3, -1):
        c_sq = c ** 2
        for b in range(c-1, int(c / math.sqrt(2)), -1):
            a = n - c - b
            if a ** 2 + b ** 2 == c_sq:
                return a * b * c
    return -1
